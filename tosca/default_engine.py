import os, stat, datetime, shutil, argparse
import yaml
from engine import Engine
from cStringIO import StringIO

class DefaultEngine(Engine):
    def __init__(self):
        self.validate_parser = argparse.ArgumentParser(prog='validate', description='converts YAML to Python')
        self.validate_parser.add_argument('name', help='blueprint filename (without the extension)')
        self.validate_parser.add_argument('-f', '--force', action='store_true', help='always create a new Python file even if it is not out of date')
    
    def handle(self, command):
        if command.name == 'validate':
            self.validate(command)

    
    def validate(self, command):
        arguments = self.validate_parser.parse_args(command.arguments)
        blueprint_name = arguments.name
        yaml_name = blueprint_name + '.yaml'
        py_name = blueprint_name + '.py'
        
        # File modification times
        try:
            yaml_time = os.path.getmtime(yaml_name)
        except OSError:
            yaml_time = 0
        try:
            py_time = os.path.getmtime(py_name)
        except OSError:
            py_time = 0
        
        # Conversions
        if arguments.force or (yaml_time > py_time):
            self.convert_yaml_to_py(yaml_name, py_name)
        elif py_time > yaml_time:
            self.convert_py_to_yaml(py_name, yaml_name)
            
        command.handled = True

    def convert_yaml_to_py(self, yaml_name, py_name):
        with open(yaml_name, 'r') as f:
            blueprint = f.read()
        blueprint = yaml.load(blueprint)
        
        s = StringIO()
        
        s.write('#!/usr/bin/env python\n\n')
        
        s.write("'''\n")
        s.write('This blueprint was generated by tosca.py on %s.\n' % datetime.datetime.utcnow())
        s.write("'''\n\n")
        
        s.write('import tosca.blueprint\n\n')
        
        s.write('try:\n')
        s.write('    ctx\n')
        s.write('except NameError:\n')
        s.write('    ctx = tosca.blueprint.Context()\n\n')

        if 'description' in blueprint:
            s.write('ctx.description = %s\n' % self.literal_string(blueprint['description']))
        
        if 'imports' in blueprint:
            s.write('\n# Imports\n')
            for i in blueprint['imports']:
                s.write('ctx.imports.append(tosca.blueprint.Import(url=%s))\n' % self.literal_string(i))

        if 'inputs' in blueprint:
            s.write('\n#\n# Inputs\n#\n')
            for name, i in blueprint['inputs'].iteritems():
                s.write('\n# %s\n' % name)
                s.write('input = ctx.input[%s] = tosca.blueprint.Input(description=%s)\n' % (repr(name), self.literal_string(i['description'])))

        if 'outputs' in blueprint:
            s.write('\n#\n# Outputs\n#\n')
            for output_name, o in blueprint['outputs'].iteritems():
                s.write('\n# %s\n' % output_name)
                s.write('output = ctx.output[%s] = tosca.blueprint.Output(description=%s)\n' % (repr(output_name), self.literal_string(o['description'])))
                for value_name, v in o['value'].iteritems():
                    method = v.keys()[0]
                    arguments = v[method]
                    s.write('output.value[%s] = tosca.blueprint.MethodValue(None, %s, %s)\n' % (repr(value_name), repr(method), repr(arguments)))

        if 'node_templates' in blueprint:
            s.write('\n#\n# Node templates\n#\n')
            for template_name, t in blueprint['node_templates'].iteritems():
                s.write('\n# %s\n' % template_name)
                s.write('node_template = ctx.node_template[%s] = tosca.blueprint.NodeTemplate(type=%s)\n' % (repr(template_name), self.literal_string(t['type'])))
                if 'relationships' in t:
                    for r in t['relationships']:
                        s.write('relationship = tosca.blueprint.Relationship(type=%s)\n' % (repr(r['type'])))
                        s.write('node_template.relationships.append(relationship)\n')
                        if 'target' in r:
                            s.write('relationship.target = %s\n' % repr(r['target']))
                        if 'target_interfaces' in r:
                            for interface_name, i in r['target_interfaces'].iteritems():
                                s.write('relationship.target_interface[%s] = %s\n' % (repr(interface_name), repr(i)))
                if 'properties' in t:
                    for property_name, v in t['properties'].iteritems():
                        method = v.keys()[0]
                        arguments = v[method]
                        s.write('relationship.property[%s] = tosca.blueprint.MethodValue(None, %s, %s)\n' % (repr(property_name), repr(method), repr(arguments)))
        
        #s.write(str(blueprint))
        
        print s.getvalue()
        
        self.backup(py_name)
        with open(py_name, 'w') as f:
            s.seek(0)
            shutil.copyfileobj(s, f)
        os.chmod(py_name, os.stat(py_name).st_mode | stat.S_IEXEC)

    def convert_py_to_yaml(self, py_name, yaml_name):
        #self.backup(yaml_name)
        pass
    
    def backup(self, name):
        '''Adds a .bak.# extension to the file, where # is incremented if it already exists'''
        i = 0
        while True:
            i += 1
            backup = '%s.bak.%d' % (name, i)
            if not os.path.isfile(backup):
                os.rename(name, backup)
                break
    
    def literal_string(self, value):
        return repr(value)
